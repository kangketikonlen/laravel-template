on:
  push:
    branches:
      - "main"

env:
  image_name: ${{ github.event.repository.name }}

name: ğŸ“œ Test, pack & ship!
jobs:
  test:
    name: âœ… Run Tests
    runs-on: ubuntu-latest
    environment: production
    services:
      mysql:
        image: mysql:8.0
        env:
          MYSQL_ROOT_PASSWORD: testing
          MYSQL_DATABASE: larapulse
        ports:
          - 3306:3306
        options: --health-cmd="mysqladmin ping" --health-interval=10s --health-timeout=5s --health-retries=3
    steps:
      - name: ğŸ™ Git checkout
        uses: actions/checkout@v3
      - name: ğŸ“ Make sure repository is latest
        run: git fetch --prune --unshallow
      - name: ğŸ“‘ Set up php
        uses: shivammathur/setup-php@v2
        with:
          php-version: 8.1
      - name: â³ Install dependencies
        run: composer install --no-interaction
      - name: ğŸ“„ Create environment
        run: cp .env.example .env
      - name: ğŸ”‘ Generate app key
        run: php artisan key:generate
      - name: ğŸ’½ Set up database
        run: php artisan migrate --seed --env=testing
      - name: ğŸ—ºï¸ Check routes
        run: php artisan route:clear && php artisan route:list
      - name: âœ… Run php tests
        run: vendor/bin/phpunit
  tagging:
    needs: test
    name: ğŸ·ï¸ Tagging the app
    runs-on: ubuntu-latest
    environment: production
    steps:
      - name: ğŸ™ Git checkout
        uses: actions/checkout@v3
      - name: ğŸ“ Make sure repository is latest
        run: git fetch --prune --unshallow
      - name: ğŸ”– Create tag
        uses: kangketikonlen/base-tagging@main
        env:
          REPO_NAME: ${{ github.event.repository.name }}
          REPO_TYPE: ${{ github.event.repository.owner.type }}
          REPO_OWNER: ${{ github.event.repository.owner.name }}
          PERSONAL_TOKEN: ${{ secrets.PERSONAL_TOKEN }}
          PRESERVE_VERSION: 5
  build:
    needs: [test, tagging]
    name: ğŸ“¦ Build the app
    runs-on: ubuntu-latest
    environment: production
    outputs:
      latest_version: ${{steps.push-image.outputs.version}}
    steps:
    - name: ğŸ™ Git checkout
      uses: actions/checkout@v3
    - name: ğŸ“ Make sure repository is latest
      run: git fetch --prune --unshallow
    - name: ğŸ³ Build image
      run: docker build . --file Dockerfile --tag $image_name --label "runnumber=${GITHUB_RUN_ID}"
    - name: ğŸ”‘ Log in to registry
      run: echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin
    - id: push-image
      name: ğŸ›³ï¸ Push image
      run: |
        image_id=ghcr.io/${{ github.repository_owner }}/$image_name
        image_id=$(echo $image_id | tr '[A-Z]' '[a-z]')
        latest_tag=$(git describe --tags $(git rev-list --tags --max-count=1))
        latest_tag=$(echo $latest_tag | sed -e 's/^v//')
        echo image_id=$image_id
        echo latest_tag=$latest_tag
        echo "version=$latest_tag" >> $GITHUB_OUTPUT
        docker tag $image_name $image_id:$latest_tag
        docker push $image_id:$latest_tag
  deploy:
    needs: [test, tagging, build]
    name: ğŸ–¥ï¸ Upload to server
    runs-on: ubuntu-latest
    environment: production
    steps:
    - name: ğŸ™ Git checkout
      uses: actions/checkout@v3
    - name: ğŸ“ Make sure repository is latest
      run: git fetch --prune --unshallow
    - name: ğŸš€ Update server
      uses: cross-the-world/ssh-scp-ssh-pipelines@latest
      with:
        host: ${{ secrets.SERVER }}
        user: ${{ secrets.USERNAME }}
        pass: ${{ secrets.PASSWORD }}
        port: ${{ secrets.SSH_PORT }}
        connect_timeout: 120s
        first_ssh: |
          cd ${{ secrets.DIRECTORY }}
          sed -i "s/IMAGE_VERSION=.*/IMAGE_VERSION=${{ needs.build.outputs.latest_version }}/g" run.sh
          bash run.sh
  check-server:
    needs: deploy
    name: ğŸŒ Check Server Status
    runs-on: ubuntu-latest
    environment: production
    steps:
      - name: ğŸ›ï¸ Check Server Status
        run: |
          server_ip=${{ secrets.SERVER }}
          server_port=${{ secrets.WEB_PORT }}
          response=$(curl -s -o /dev/null -w "%{http_code}" http://$server_ip:$server_port)
          if [[ "$response" -eq 200 ]]; then
            echo "Server is up and running!"
          else
            echo "Server is not responding."
            exit 1
          fi
